<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Byte (containers-data.CCRingBuffer.Byte)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">containers-data</a> &#x00BB; <a href="../index.html">CCRingBuffer</a> &#x00BB; Byte</nav><h1>Module <code>CCRingBuffer.Byte</code></h1><p>An efficient byte based ring buffer</p></header><dl><dt class="spec module" id="module-Array"><a href="#module-Array" class="anchor"></a><code><span class="keyword">module</span> Array = <a href="../Array/index.html#module-Byte">Array.Byte</a></code></dt><dd><p>The module type of Array for this ring buffer</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>Defines the bounded ring buffer type</p></dd></dl><dl><dt class="spec exception" id="exception-Empty"><a href="#exception-Empty" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Empty</span></code></dt><dd><p>Raised in querying functions when the buffer is empty</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create size</code> creates a new bounded buffer with given size. The underlying array is allocated immediately and no further (large) allocation will happen from now on.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the argument is <code>&lt; 1</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Make a fresh copy of the buffer.</p></dd></dl><dl><dt class="spec value" id="val-capacity"><a href="#val-capacity" class="anchor"></a><code><span class="keyword">val</span> capacity : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Length of the inner buffer.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Number of elements currently stored in the buffer.</p></dd></dl><dl><dt class="spec value" id="val-is_full"><a href="#val-is_full" class="anchor"></a><code><span class="keyword">val</span> is_full : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>true</code> if pushing an element would erase another element.</p><dl><dt>since</dt><dd>1.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-blit_from"><a href="#val-blit_from" class="anchor"></a><code><span class="keyword">val</span> blit_from : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Array/index.html#type-t">Array.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit_from buf from_buf o len</code> copies the slice <code>o, ... o + len - 1</code> from an input buffer <code>from_buf</code> to the end of the buffer. If the slice is too large for the buffer, only the last part of the array will be copied.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>o,len</code> is not a valid slice of <code>s</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-blit_into"><a href="#val-blit_into" class="anchor"></a><code><span class="keyword">val</span> blit_into : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Array/index.html#type-t">Array.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>blit_into buf to_buf o len</code> copies at most <code>len</code> elements from <code>buf</code> into <code>to_buf</code> starting at offset <code>o</code> in <code>s</code>.</p><dl><dt>returns</dt><dd><p>the number of elements actually copied (<code>min len (length buf)</code>).</p></dd></dl><dl><dt>raises Invalid_argument</dt><dd><p>if <code>o,len</code> is not a valid slice of <code>s</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>into:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>append b ~into</code> copies all data from <code>b</code> and adds it at the end of <code>into</code>. Erases data of <code>into</code> if there is not enough room.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Array/index.html#type-elt">Array.elt</a> list</span></code></dt><dd><p>Extract the current content into a list.</p></dd></dl><dl><dt class="spec value" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span class="keyword">val</span> clear : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Clear the content of the buffer</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the buffer empty (i.e. contains no elements)?</p></dd></dl><dl><dt class="spec value" id="val-junk_front"><a href="#val-junk_front" class="anchor"></a><code><span class="keyword">val</span> junk_front : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Drop the front element from <code>t</code>.</p><dl><dt>raises Empty</dt><dd><p>if the buffer is already empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-junk_back"><a href="#val-junk_back" class="anchor"></a><code><span class="keyword">val</span> junk_back : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Drop the back element from <code>t</code>.</p><dl><dt>raises Empty</dt><dd><p>if the buffer is already empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-skip"><a href="#val-skip" class="anchor"></a><code><span class="keyword">val</span> skip : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>skip b len</code> removes <code>len</code> elements from the front of <code>b</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>len &gt; length b</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="Array/index.html#type-elt">Array.elt</a> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter b ~f</code> calls <code>f i t</code> for each element <code>t</code> in <code>buf</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(int <span>&#45;&gt;</span> <a href="Array/index.html#type-elt">Array.elt</a> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri b ~f</code> calls <code>f i t</code> for each element <code>t</code> in <code>buf</code>, with <code>i</code> being its relative index within <code>buf</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_front"><a href="#val-get_front" class="anchor"></a><code><span class="keyword">val</span> get_front : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Array/index.html#type-elt">Array.elt</a></code></dt><dd><p><code>get_front buf i</code> returns the <code>i</code>-th element of <code>buf</code> from the front, i.e. the one returned by <code>take_front buf</code> after <code>i-1</code> calls to <code>junk_front buf</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the index is invalid (&gt; <code>length buf</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_back"><a href="#val-get_back" class="anchor"></a><code><span class="keyword">val</span> get_back : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Array/index.html#type-elt">Array.elt</a></code></dt><dd><p><code>get_back buf i</code> returns the <code>i</code>-th element of <code>buf</code> from the back, i.e. the one returned by <code>take_back buf</code> after <code>i-1</code> calls to <code>junk_back buf</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the index is invalid (&gt; <code>length buf</code>).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-push_back"><a href="#val-push_back" class="anchor"></a><code><span class="keyword">val</span> push_back : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Array/index.html#type-elt">Array.elt</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Push value at the back of <code>t</code>. If <code>t.bounded=false</code>, the buffer will grow as needed, otherwise the oldest elements are replaced first.</p></dd></dl><dl><dt class="spec value" id="val-peek_front"><a href="#val-peek_front" class="anchor"></a><code><span class="keyword">val</span> peek_front : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Array/index.html#type-elt">Array.elt</a> option</span></code></dt><dd><p>First value from front of <code>t</code>, without modification.</p></dd></dl><dl><dt class="spec value" id="val-peek_front_exn"><a href="#val-peek_front_exn" class="anchor"></a><code><span class="keyword">val</span> peek_front_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Array/index.html#type-elt">Array.elt</a></code></dt><dd><p>First value from front of <code>t</code>, without modification.</p><dl><dt>raises Empty</dt><dd><p>if buffer is empty.</p></dd></dl><dl><dt>since</dt><dd>1.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-peek_back"><a href="#val-peek_back" class="anchor"></a><code><span class="keyword">val</span> peek_back : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Array/index.html#type-elt">Array.elt</a> option</span></code></dt><dd><p>Get the last value from back of <code>t</code>, without modification.</p></dd></dl><dl><dt class="spec value" id="val-peek_back_exn"><a href="#val-peek_back_exn" class="anchor"></a><code><span class="keyword">val</span> peek_back_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Array/index.html#type-elt">Array.elt</a></code></dt><dd><p>Get the last value from back of <code>t</code>, without modification.</p><dl><dt>raises Empty</dt><dd><p>if buffer is empty.</p></dd></dl><dl><dt>since</dt><dd>1.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-take_back"><a href="#val-take_back" class="anchor"></a><code><span class="keyword">val</span> take_back : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Array/index.html#type-elt">Array.elt</a> option</span></code></dt><dd><p>Take and remove the last value from back of <code>t</code>, if any.</p></dd></dl><dl><dt class="spec value" id="val-take_back_exn"><a href="#val-take_back_exn" class="anchor"></a><code><span class="keyword">val</span> take_back_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Array/index.html#type-elt">Array.elt</a></code></dt><dd><p>Take and remove the last value from back of <code>t</code>.</p><dl><dt>raises Empty</dt><dd><p>if buffer is already empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-take_front"><a href="#val-take_front" class="anchor"></a><code><span class="keyword">val</span> take_front : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Array/index.html#type-elt">Array.elt</a> option</span></code></dt><dd><p>Take and remove the first value from front of <code>t</code>, if any.</p></dd></dl><dl><dt class="spec value" id="val-take_front_exn"><a href="#val-take_front_exn" class="anchor"></a><code><span class="keyword">val</span> take_front_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Array/index.html#type-elt">Array.elt</a></code></dt><dd><p>Take and remove the first value from front of <code>t</code>.</p><dl><dt>raises Empty</dt><dd><p>if buffer is already empty.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <a href="Array/index.html#type-t">Array.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a buffer from an initial array, but doesn't take ownership of it (still allocates a new internal array).</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Array/index.html#type-t">Array.t</a></code></dt><dd><p>Create an array from the elements, in order.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl></div></body></html>