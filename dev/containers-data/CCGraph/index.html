<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CCGraph (containers-data.CCGraph)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">containers-data</a> &#x00BB; CCGraph</nav><h1>Module <code>CCGraph</code></h1><h2 id="simple-graph-interface"><a href="#simple-graph-interface" class="anchor"></a>Simple Graph Interface</h2><p>A collections of algorithms on (mostly read-only) graph structures. The user provides her own graph structure as a <code>('v, 'e) CCGraph.t</code>, where <code>'v</code> is the type of vertices and <code>'e</code> the type of edges (for instance, <code>'e = ('v * 'v)</code> is perfectly fine in many cases).</p><p>Such a <code>('v, 'e) CCGraph.t</code> structure is a record containing three functions: two relate edges to their origin and destination, and one maps vertices to their outgoing edges. This abstract notion of graph makes it possible to run the algorithms on any user-specific type that happens to have a graph structure.</p><p>Many graph algorithms here take an iterator of vertices as input. The helper module <a href="Iter/index.html"><code>Iter</code></a> contains basic functions for that, as does the <code>iter</code> library on opam. If the user only has a single vertex (e.g., for a topological sort from a given vertex), they can use <code>Iter.return x</code> to build a iter of one element.</p><p><b>status: unstable</b></p><dl><dt>since</dt><dd>0.12</dd></dl><nav class="toc"><ul><li><a href="#iter-helpers">Iter Helpers</a></li><li><a href="#interfaces-for-graphs">Interfaces for graphs</a></li><li><a href="#bags-of-vertices">Bags of vertices</a></li><li><a href="#traversals">Traversals</a></li><li><a href="#cycles">Cycles</a></li><li><a href="#topological-sort">Topological Sort</a></li><li><a href="#lazy-spanning-tree">Lazy Spanning Tree</a></li><li><a href="#strongly-connected-components">Strongly Connected Components</a></li><li><a href="#pretty-printing-in-the-dot-(graphviz)-format">Pretty printing in the DOT (graphviz) format</a></li><li><a href="#mutable-graph">Mutable Graph</a></li><li><a href="#immutable-graph">Immutable Graph</a></li><li><a href="#misc">Misc</a></li></ul></nav></header><section><header><h3 id="iter-helpers"><a href="#iter-helpers" class="anchor"></a>Iter Helpers</h3></header><dl><dt class="spec type" id="type-iter"><a href="#type-iter" class="anchor"></a><code><span class="keyword">type</span> <span>'a iter</span></code><code> = <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>A sequence of items of type <code>'a</code>, possibly infinite</p><dl><dt>since</dt><dd>2.8</dd></dl></dd></dl><dl><dt class="spec type" id="type-iter_once"><a href="#type-iter_once" class="anchor"></a><code><span class="keyword">type</span> <span>'a iter_once</span></code><code> = <span><span class="type-var">'a</span> <a href="index.html#type-iter">iter</a></span></code></dt><dd><p>Iter that should be used only once</p><dl><dt>since</dt><dd>2.8</dd></dl></dd></dl><dl><dt class="spec exception" id="exception-Iter_once"><a href="#exception-Iter_once" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Iter_once</span></code></dt><dd><p>Raised when a sequence meant to be used once is used several times.</p></dd></dl><div class="spec module" id="module-Iter"><a href="#module-Iter" class="anchor"></a><code><span class="keyword">module</span> <a href="Iter/index.html">Iter</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="interfaces-for-graphs"><a href="#interfaces-for-graphs" class="anchor"></a>Interfaces for graphs</h3><p>This interface is designed for oriented graphs with labels on edges</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>('v, 'e) t</span></code><code> = <span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'e</span> * <span class="type-var">'v</span>)</span> <a href="index.html#type-iter">iter</a></span></code></dt><dd><p>Directed graph with vertices of type <code>'v</code> and edges labeled with <code>e'</code></p></dd></dl><dl><dt class="spec type" id="type-graph"><a href="#type-graph" class="anchor"></a><code><span class="keyword">type</span> <span>('v, 'e) graph</span></code><code> = <span><span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>)</span> <a href="index.html#type-t">t</a></span></code></dt></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'e</span> * <span class="type-var">'v</span>)</span> <a href="index.html#type-iter">iter</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Make a graph by providing the children function.</p></dd></dl><dl><dt class="spec type" id="type-tag_set"><a href="#type-tag_set" class="anchor"></a><code><span class="keyword">type</span> <span>'v tag_set</span></code><code> = </code><code>{</code><table class="record"><tr id="type-tag_set.get_tag" class="anchored"><td class="def field"><a href="#type-tag_set.get_tag" class="anchor"></a><code>get_tag : <span class="type-var">'v</span> <span>&#45;&gt;</span> bool;</code></td></tr><tr id="type-tag_set.set_tag" class="anchored"><td class="def field"><a href="#type-tag_set.set_tag" class="anchor"></a><code>set_tag : <span class="type-var">'v</span> <span>&#45;&gt;</span> unit;</code></td><td class="doc"><p>Set tag for the given element</p></td></tr></table><code>}</code></dt><dd><h3 id="tags"><a href="#tags" class="anchor"></a>Tags</h3><p>Mutable tags from values of type <code>'v</code> to tags of type <code>bool</code></p></dd></dl><dl><dt class="spec type" id="type-table"><a href="#type-table" class="anchor"></a><code><span class="keyword">type</span> <span>('k, 'a) table</span></code><code> = </code><code>{</code><table class="record"><tr id="type-table.mem" class="anchored"><td class="def field"><a href="#type-table.mem" class="anchor"></a><code>mem : <span class="type-var">'k</span> <span>&#45;&gt;</span> bool;</code></td></tr><tr id="type-table.find" class="anchored"><td class="def field"><a href="#type-table.find" class="anchor"></a><code>find : <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td><td class="doc"><dl><dt>raises Not_found</dt><dd><p>if element not added before</p></dd></dl></td></tr><tr id="type-table.add" class="anchored"><td class="def field"><a href="#type-table.add" class="anchor"></a><code>add : <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit;</code></td><td class="doc"><p>Erases previous binding</p></td></tr></table><code>}</code></dt><dd><h3 id="table"><a href="#table" class="anchor"></a>Table</h3><p>Mutable table with keys <code>'k</code> and values <code>'a</code></p></dd></dl><dl><dt class="spec type" id="type-set"><a href="#type-set" class="anchor"></a><code><span class="keyword">type</span> <span>'a set</span></code><code> = <span><span>(<span class="type-var">'a</span>, unit)</span> <a href="index.html#type-table">table</a></span></code></dt><dd><p>Mutable set</p></dd></dl><dl><dt class="spec value" id="val-mk_table"><a href="#val-mk_table" class="anchor"></a><code><span class="keyword">val</span> mk_table : <span>eq:<span>(<span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;hash:<span>(<span class="type-var">'k</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-table">table</a></span></code></dt><dd><p>Default implementation for <a href="index.html#type-table"><code>table</code></a>: a <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.t&quot;"><code>Hashtbl</code>.t</span>.</p></dd></dl><dl><dt class="spec value" id="val-mk_map"><a href="#val-mk_map" class="anchor"></a><code><span class="keyword">val</span> mk_map : <span>cmp:<span>(<span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span>(<span class="type-var">'k</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-table">table</a></span></code></dt><dd><p>Use a <span class="xref-unresolved" title="unresolved reference to &quot;Map.S&quot;"><a href="index.html#module-Map"><code>Map</code></a>.S</span> underneath.</p></dd></dl></section><section><header><h3 id="bags-of-vertices"><a href="#bags-of-vertices" class="anchor"></a>Bags of vertices</h3></header><dl><dt class="spec type" id="type-bag"><a href="#type-bag" class="anchor"></a><code><span class="keyword">type</span> <span>'a bag</span></code><code> = </code><code>{</code><table class="record"><tr id="type-bag.push" class="anchored"><td class="def field"><a href="#type-bag.push" class="anchor"></a><code>push : <span class="type-var">'a</span> <span>&#45;&gt;</span> unit;</code></td></tr><tr id="type-bag.is_empty" class="anchored"><td class="def field"><a href="#type-bag.is_empty" class="anchor"></a><code>is_empty : unit <span>&#45;&gt;</span> bool;</code></td></tr><tr id="type-bag.pop" class="anchored"><td class="def field"><a href="#type-bag.pop" class="anchor"></a><code>pop : unit <span>&#45;&gt;</span> <span class="type-var">'a</span>;</code></td><td class="doc"><p>raises some exception is empty</p></td></tr></table><code>}</code></dt><dd><p>Bag of elements of type <code>'a</code></p></dd></dl><dl><dt class="spec value" id="val-mk_queue"><a href="#val-mk_queue" class="anchor"></a><code><span class="keyword">val</span> mk_queue : unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-bag">bag</a></span></code></dt><dt class="spec value" id="val-mk_stack"><a href="#val-mk_stack" class="anchor"></a><code><span class="keyword">val</span> mk_stack : unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-bag">bag</a></span></code></dt><dt class="spec value" id="val-mk_heap"><a href="#val-mk_heap" class="anchor"></a><code><span class="keyword">val</span> mk_heap : <span>leq:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-bag">bag</a></span></code></dt><dd><p><code>mk_heap ~leq</code> makes a priority queue where <code>leq x y = true</code> means that <code>x</code> is smaller than <code>y</code> and should be prioritary.</p></dd></dl></section><section><header><h3 id="traversals"><a href="#traversals" class="anchor"></a>Traversals</h3></header><div class="spec module" id="module-Traverse"><a href="#module-Traverse" class="anchor"></a><code><span class="keyword">module</span> <a href="Traverse/index.html">Traverse</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="cycles"><a href="#cycles" class="anchor"></a>Cycles</h3></header><dl><dt class="spec value" id="val-is_dag"><a href="#val-is_dag" class="anchor"></a><code><span class="keyword">val</span> is_dag : <span>tbl:<span><span class="type-var">'v</span> <a href="index.html#type-set">set</a></span></span> <span>&#45;&gt;</span> <span>eq:<span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>graph:<span><span>(<span class="type-var">'v</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-iter">iter</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_dag ~graph vs</code> returns <code>true</code> if the subset of <code>graph</code> reachable from <code>vs</code> is acyclic.</p><dl><dt>since</dt><dd>0.18</dd></dl></dd></dl></section><section><header><h3 id="topological-sort"><a href="#topological-sort" class="anchor"></a>Topological Sort</h3></header><dl><dt class="spec exception" id="exception-Has_cycle"><a href="#exception-Has_cycle" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Has_cycle</span></code></dt></dl><dl><dt class="spec value" id="val-topo_sort"><a href="#val-topo_sort" class="anchor"></a><code><span class="keyword">val</span> topo_sort : <span>eq:<span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>tbl:<span><span class="type-var">'v</span> <a href="index.html#type-set">set</a></span></span> <span>&#45;&gt;</span> <span>graph:<span><span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>)</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-iter">iter</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> list</span></code></dt><dd><p><code>topo_sort ~graph seq</code> returns a list of vertices <code>l</code> where each element of <code>l</code> is reachable from <code>seq</code>. The list is sorted in a way such that if <code>v -&gt; v'</code> in the graph, then <code>v</code> comes before <code>v'</code> in the list (i.e. has a smaller index). Basically <code>v -&gt; v'</code> means that <code>v</code> is smaller than <code>v'</code>. See <a href="https://en.wikipedia.org/wiki/Topological_sorting">wikipedia</a>.</p><dl><dt>parameter eq</dt><dd><p>equality predicate on vertices (default <code>(=)</code>).</p></dd></dl><dl><dt>parameter rev</dt><dd><p>if true, the dependency relation is inverted (<code>v -&gt; v'</code> means <code>v'</code> occurs before <code>v</code>).</p></dd></dl><dl><dt>raises Has_cycle</dt><dd><p>if the graph is not a DAG.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-topo_sort_tag"><a href="#val-topo_sort_tag" class="anchor"></a><code><span class="keyword">val</span> topo_sort_tag : <span>eq:<span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;rev:bool</span> <span>&#45;&gt;</span> <span>tags:<span><span class="type-var">'v</span> <a href="index.html#type-tag_set">tag_set</a></span></span> <span>&#45;&gt;</span> <span>graph:<span><span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>)</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-iter">iter</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> list</span></code></dt><dd><p>Same as <a href="index.html#val-topo_sort"><code>topo_sort</code></a> but uses an explicit tag set.</p><dl><dt>raises Has_cycle</dt><dd><p>if the graph is not a DAG.</p></dd></dl></dd></dl></section><section><header><h3 id="lazy-spanning-tree"><a href="#lazy-spanning-tree" class="anchor"></a>Lazy Spanning Tree</h3></header><div class="spec module" id="module-Lazy_tree"><a href="#module-Lazy_tree" class="anchor"></a><code><span class="keyword">module</span> <a href="Lazy_tree/index.html">Lazy_tree</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-spanning_tree"><a href="#val-spanning_tree" class="anchor"></a><code><span class="keyword">val</span> spanning_tree : <span>tbl:<span><span class="type-var">'v</span> <a href="index.html#type-set">set</a></span></span> <span>&#45;&gt;</span> <span>graph:<span><span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>)</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>)</span> <a href="Lazy_tree/index.html#type-t">Lazy_tree.t</a></span></code></dt><dd><p><code>spanning_tree ~graph v</code> computes a lazy spanning tree that has <code>v</code> as a root. The table <code>tbl</code> is used for the memoization part.</p></dd></dl><dl><dt class="spec value" id="val-spanning_tree_tag"><a href="#val-spanning_tree_tag" class="anchor"></a><code><span class="keyword">val</span> spanning_tree_tag : <span>tags:<span><span class="type-var">'v</span> <a href="index.html#type-tag_set">tag_set</a></span></span> <span>&#45;&gt;</span> <span>graph:<span><span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>)</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>)</span> <a href="Lazy_tree/index.html#type-t">Lazy_tree.t</a></span></code></dt></dl></section><section><header><h3 id="strongly-connected-components"><a href="#strongly-connected-components" class="anchor"></a>Strongly Connected Components</h3></header><dl><dt class="spec type" id="type-scc_state"><a href="#type-scc_state" class="anchor"></a><code><span class="keyword">type</span> <span>'v scc_state</span></code></dt><dd><p>Hidden state for <a href="index.html#val-scc"><code>scc</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-scc"><a href="#val-scc" class="anchor"></a><code><span class="keyword">val</span> scc : <span>tbl:<span><span>(<span class="type-var">'v</span>, <span><span class="type-var">'v</span> <a href="index.html#type-scc_state">scc_state</a></span>)</span> <a href="index.html#type-table">table</a></span></span> <span>&#45;&gt;</span> <span>graph:<span><span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>)</span> <a href="index.html#type-t">t</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> <a href="index.html#type-iter">iter</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'v</span> list</span> <a href="index.html#type-iter_once">iter_once</a></span></code></dt><dd><p>Strongly connected components reachable from the given vertices. Each component is a list of vertices that are all mutually reachable in the graph. The components are explored in a topological order (if C1 and C2 are components, and C1 points to C2, then C2 will be yielded before C1). Uses <a href="https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm">Tarjan's algorithm</a>.</p><dl><dt>parameter tbl</dt><dd><p>table used to map nodes to some hidden state.</p></dd></dl><dl><dt>raises Iter_once</dt><dd><p>if the result is iterated on more than once.</p></dd></dl></dd></dl></section><section><header><h3 id="pretty-printing-in-the-dot-(graphviz)-format"><a href="#pretty-printing-in-the-dot-(graphviz)-format" class="anchor"></a>Pretty printing in the DOT (graphviz) format</h3><p>Example (print divisors from <code>42</code>):</p><pre><code class="ml">let open CCGraph in
let open Dot in
with_out &quot;/tmp/truc.dot&quot;
  (fun out -&gt;
     pp ~attrs_v:(fun i -&gt; [`Label (string_of_int i)]) ~graph:divisors_graph out 42
  )</code></pre></header><div class="spec module" id="module-Dot"><a href="#module-Dot" class="anchor"></a><code><span class="keyword">module</span> <a href="Dot/index.html">Dot</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h3 id="mutable-graph"><a href="#mutable-graph" class="anchor"></a>Mutable Graph</h3></header><dl><dt class="spec type" id="type-mut_graph"><a href="#type-mut_graph" class="anchor"></a><code><span class="keyword">type</span> <span>('v, 'e) mut_graph</span></code><code> = </code><code>{</code><table class="record"><tr id="type-mut_graph.graph" class="anchored"><td class="def field"><a href="#type-mut_graph.graph" class="anchor"></a><code>graph : <span><span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>)</span> <a href="index.html#type-t">t</a></span>;</code></td></tr><tr id="type-mut_graph.add_edge" class="anchored"><td class="def field"><a href="#type-mut_graph.add_edge" class="anchor"></a><code>add_edge : <span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'e</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> unit;</code></td></tr><tr id="type-mut_graph.remove" class="anchored"><td class="def field"><a href="#type-mut_graph.remove" class="anchor"></a><code>remove : <span class="type-var">'v</span> <span>&#45;&gt;</span> unit;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-mk_mut_tbl"><a href="#val-mk_mut_tbl" class="anchor"></a><code><span class="keyword">val</span> mk_mut_tbl : <span>eq:<span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;hash:<span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-mut_graph">mut_graph</a></span></code></dt><dd><p>Make a new mutable graph from a Hashtbl. Edges are labelled with type <code>'a</code>.</p></dd></dl></section><section><header><h3 id="immutable-graph"><a href="#immutable-graph" class="anchor"></a>Immutable Graph</h3><p>A classic implementation of a graph structure on totally ordered vertices, with unlabelled edges. The graph allows to add and remove edges and vertices, and to iterate on edges and vertices.</p></header><div class="spec module-type" id="module-type-MAP"><a href="#module-type-MAP" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MAP/index.html">MAP</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map/index.html">Map</a> : <span class="keyword">functor</span> (<a href="Map/index.html#argument-1-O">O</a> : Stdlib.Map.OrderedType) <span>&#45;&gt;</span> <a href="index.html#module-type-MAP">MAP</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Map/index.html#type-vertex">vertex</a> = <a href="Map/index.html#argument-1-O">O</a>.t</code></div></section><section><header><h3 id="misc"><a href="#misc" class="anchor"></a>Misc</h3></header><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span>eq:<span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span> * <span class="type-var">'v</span>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_list l</code> makes a graph from a list of pairs of vertices. Each pair <code>(a,b)</code> is an edge from <code>a</code> to <code>b</code>.</p><dl><dt>parameter eq</dt><dd><p>equality used to compare vertices.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_hashtbl"><a href="#val-of_hashtbl" class="anchor"></a><code><span class="keyword">val</span> of_hashtbl : <span><span>(<span class="type-var">'v</span>, <span><span class="type-var">'v</span> list</span>)</span> Stdlib.Hashtbl.t</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_hashtbl tbl</code> makes a graph from a hashtable that maps vertices to lists of children.</p></dd></dl><dl><dt class="spec value" id="val-of_fun"><a href="#val-of_fun" class="anchor"></a><code><span class="keyword">val</span> of_fun : <span>(<span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span class="type-var">'v</span> list</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'v</span>, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_fun f</code> makes a graph out of a function that maps a vertex to the list of its children. The function is assumed to be deterministic.</p></dd></dl><dl><dt class="spec value" id="val-divisors_graph"><a href="#val-divisors_graph" class="anchor"></a><code><span class="keyword">val</span> divisors_graph : <span><span>(int, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>n</code> points to all its strict divisors.</p></dd></dl></section></div></body></html>