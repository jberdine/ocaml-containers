<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Traverse (containers.CCList.Traverse)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">containers</a> &#x00BB; <a href="../index.html">CCList</a> &#x00BB; Traverse</nav><h1>Module <code>CCList.Traverse</code></h1><h3 id="monadic-traverse"><a href="#monadic-traverse" class="anchor"></a>Monadic Traverse</h3><p>This allows the traversal of a <code>'a t list</code> where <code>_ t</code> is also a monad.</p><p>For example, a <code>'a option list</code> will be traversed by extracting a value from each option, returning <code>Some [x1;…;x_n]</code>; but if one of the option is <code>None</code> then the whole result is <code>None</code>.</p><p>Another example is with <code>result</code>: <code>('a, 'err) result list</code> can be transformed into <code>('a list, 'err) result</code> by returning the first error, or <code>Ok [x1; …; xn]</code> if all the elements were successful.</p><p>This describes the behavior of <code>sequence_m</code>; <code>map_m</code> is a combination of <a href="../index.html#val-map"><code>map</code></a> and <code>sequence_m</code>; <code>map_m_par</code> is like <code>map_m</code> but useful for some pseudo monads like Lwt.</p></header><h3 class="heading">Parameters</h3><ul><li><code><a href="argument-1-M/index.html">M</a> : <a href="../index.html#module-type-MONAD">MONAD</a></code></li></ul><h3 class="heading">Signature</h3><dl><dt class="spec value" id="val-sequence_m"><a href="#val-sequence_m" class="anchor"></a><code><span class="keyword">val</span> sequence_m : <span><span><span class="type-var">'a</span> <a href="argument-1-M/index.html#type-t">M.t</a></span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <a href="argument-1-M/index.html#type-t">M.t</a></span></code></dt><dd><p>Traverse the list of monadic values using <a href="argument-1-M/index.html#val-(&gt;&gt;=)"><code>M.(&gt;&gt;=)</code></a>, re-combining elements with <code>(::)</code>. See the documentation of the <a href="index.html"><code>Traverse</code></a> functor itself.</p></dd></dl><dl><dt class="spec value" id="val-fold_m"><a href="#val-fold_m" class="anchor"></a><code><span class="keyword">val</span> fold_m : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="argument-1-M/index.html#type-t">M.t</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="argument-1-M/index.html#type-t">M.t</a></span></code></dt><dd><p>Fold a function with a monadic effect through a list.</p></dd></dl><dl><dt class="spec value" id="val-map_m"><a href="#val-map_m" class="anchor"></a><code><span class="keyword">val</span> map_m : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="argument-1-M/index.html#type-t">M.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span> <a href="argument-1-M/index.html#type-t">M.t</a></span></code></dt><dd><p>Combination of <a href="../index.html#val-map"><code>map</code></a> and <a href="index.html#val-sequence_m"><code>sequence_m</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-map_m_par"><a href="#val-map_m_par" class="anchor"></a><code><span class="keyword">val</span> map_m_par : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="argument-1-M/index.html#type-t">M.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="../index.html#type-t">t</a></span> <a href="argument-1-M/index.html#type-t">M.t</a></span></code></dt><dd><p><code>map_m_par f (x :: l)</code> is like <a href="index.html#val-map_m"><code>map_m</code></a> but <code>f x</code> and <code>f l</code> are evaluated &quot;in parallel&quot; before combining their result (for instance in Lwt).</p><p>Basically, when encoutering <code>x :: tl</code>, this computes <code>f x</code> and <code>map_m_par f tl</code>, and only then is <code>M.(&gt;&gt;=)</code> used to combine the two results into a new list.</p></dd></dl></div></body></html>